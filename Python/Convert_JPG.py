#!/usr/bin/env python3
"""
convert_to_c_array_any_size.py with optional gamma correction

Usage:
  python convert_to_c_array_any_size.py input.jpg output.h array_name [--width W] [--height H] [--no-resize] [--gamma G]

If --gamma G provided (e.g. 2.2), performs gamma correction using simple power-law:
 - linearize channels: C_lin = (C/255) ** G
 - compute luminance in linear space using BT.709 weights
 - apply inverse gamma: Y = (Y_lin) ** (1/G)
 - map Y (0..1) -> 0..255 then quantize to 0..31
"""
from PIL import Image
import numpy as np
import sys
import os
import argparse
import textwrap

def parse_args():
    p = argparse.ArgumentParser(description="Convert image to packed 5-bit grayscale C array (optional gamma)")
    p.add_argument("input", help="Input image (JPEG/PNG...)")
    p.add_argument("output", help="Output .h file")
    p.add_argument("array_name", help="Name of C array (e.g., image_data)")
    p.add_argument("--width", type=int, help="Target width (pixels). If omitted, use image width.")
    p.add_argument("--height", type=int, help="Target height (pixels). If omitted, use image height.")
    p.add_argument("--no-resize", action="store_true", help="Do not resize the image; use its original size")
    p.add_argument("--bytes-per-line", type=int, default=12, help="Hex items per line in generated .h (readability)")
    p.add_argument("--gamma", type=float, default=None, help="Gamma value for correction (e.g. 2.2). If omitted, no gamma applied.")
    return p.parse_args()

def load_image(path):
    img = Image.open(path).convert('RGB')
    return img

def resize_or_pad(img, target_w, target_h, no_resize=False):
    if no_resize:
        return img
    img_thumb = img.copy()
    img_thumb.thumbnail((target_w, target_h), Image.LANCZOS)
    if img_thumb.size == (target_w, target_h):
        return img_thumb
    out = Image.new('RGB', (target_w, target_h), (0,0,0))
    x = (target_w - img_thumb.width) // 2
    y = (target_h - img_thumb.height) // 2
    out.paste(img_thumb, (x,y))
    return out

def rgb_to_luma_8bit_with_gamma(rgb_arr, gamma=None):
    """
    rgb_arr: uint8 array H,W,3
    gamma: None or float G
    returns uint8 luma 0..255
    """
    if gamma is None:
        # original linear formula BT.601 mapping to 0..255
        r = rgb_arr[...,0].astype(np.float32)
        g = rgb_arr[...,1].astype(np.float32)
        b = rgb_arr[...,2].astype(np.float32)
        y = 0.299*r + 0.587*g + 0.114*b
        return np.clip(y,0,255).astype(np.uint8)
    else:
        # use power-law gamma correction with LUT for speed
        G = float(gamma)
        invG = 1.0 / G
        # BT.709 linear luminance weights
        Wr, Wg, Wb = 0.2126, 0.7152, 0.0722
        # build LUT: value -> linearized (0..1)
        lut_lin = np.array([((i / 255.0) ** G) for i in range(256)], dtype=np.float32)  # C_lin
        r_lin = lut_lin[rgb_arr[...,0]]
        g_lin = lut_lin[rgb_arr[...,1]]
        b_lin = lut_lin[rgb_arr[...,2]]
        y_lin = Wr * r_lin + Wg * g_lin + Wb * b_lin  # 0..1
        # inverse gamma
        y_nl = np.power(np.clip(y_lin, 0.0, 1.0), invG)
        y8 = np.clip((y_nl * 255.0), 0, 255).astype(np.uint8)
        return y8

def quantize5(y8):
    return ((y8.astype(np.uint16) * 31 + 127) // 255).astype(np.uint8)

def pack_triplet(r5, g5, b5):
    r = int(r5) & 0x1F
    g = int(g5) & 0x1F
    b = int(b5) & 0x1F
    byte0 = ((r & 0x1F) << 3) | ((g >> 2) & 0x07)
    byte1 = (((g & 0x07) << 5) | (b & 0x1F)) & 0xFF
    return byte0 & 0xFF, byte1

def convert_image_to_bytes(img, gamma=None):
    arr = np.array(img)  # H,W,3
    luma = rgb_to_luma_8bit_with_gamma(arr, gamma=gamma)
    q5 = quantize5(luma)
    H,W = q5.shape
    pad = (3 - (W % 3)) % 3
    if pad:
        q5 = np.pad(q5, ((0,0),(0,pad)), constant_values=0)
        W = q5.shape[1]
    out = bytearray()
    for y in range(H):
        x = 0
        while x < W:
            r5 = int(q5[y, x + 0])
            g5 = int(q5[y, x + 1])
            b5 = int(q5[y, x + 2])
            b0, b1 = pack_triplet(r5, g5, b5)
            out.append(b0)
            out.append(b1)
            x += 3
    return out, q5.shape[1]  # return padded width too

def write_c_header(path_out, array_name, data_bytes, width, height, padded_width, bytes_per_line=12):
    total = len(data_bytes)
    bytes_per_row = ((width + 2) // 3) * 2
    hex_items = [f"0x{b:02X}" for b in data_bytes]
    lines = []
    for i in range(0, len(hex_items), bytes_per_line):
        chunk = ", ".join(hex_items[i:i+bytes_per_line])
        if i + bytes_per_line < len(hex_items):
            chunk += ","
        lines.append("  " + chunk)
    header = []
    header.append("// Generated by convert_to_c_array_any_size.py")
    header.append(f"// Image size: {width} x {height} (padded width for packing: {padded_width})")
    header.append(f"// bytes_per_row = {bytes_per_row}, total bytes = {total}")
    header.append("")
    header.append("#include <stdint.h>")
    header.append("")
    header.append(f"const uint8_t {array_name}[] = {{")
    header.extend(lines)
    header.append("};")
    header.append("")
    header.append(f"const unsigned {array_name}_width = {width};")
    header.append(f"const unsigned {array_name}_height = {height};")
    header.append(f"const unsigned {array_name}_bytes_per_row = {bytes_per_row};")
    header.append(f"const unsigned {array_name}_size = {total};")
    with open(path_out, "w", newline="\n") as f:
        f.write("\n".join(header))
    print(f"Wrote {total} bytes -> {path_out}")

def main():
    args = parse_args()
    if not os.path.isfile(args.input):
        print("Input not found:", args.input); sys.exit(1)
    img = load_image(args.input)
    # Determine target size
    if args.width and args.height:
        target_w = args.width
        target_h = args.height
    elif args.width and not args.height:
        target_w = args.width
        target_h = img.height * args.width // img.width
    elif args.height and not args.width:
        target_h = args.height
        target_w = img.width * args.height // img.height
    else:
        target_w = img.width
        target_h = img.height

    if not args.no_resize:
        img_prepared = resize_or_pad(img, target_w, target_h, no_resize=False)
    else:
        img_prepared = img
        target_w = img_prepared.width
        target_h = img_prepared.height

    data_bytes, padded_width = convert_image_to_bytes(img_prepared, gamma=args.gamma)
    write_c_header(args.output, args.array_name, data_bytes, target_w, target_h, padded_width, args.bytes_per_line)

if __name__ == "__main__":
    main()